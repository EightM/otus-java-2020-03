*-Xms256m
-Xmx256m*
* Добавление по 2.5к элементов в коллецию, sleep 1000ms

| GC |  YoungCollections | OldCollections  | Итого |
| ------------ | ------------ | ----------- | ----------- |
|  G1 |  27 (0.526s) |  15 (4,622s) | 5,148s |

| GC |  Copy | MarkSweepCompact  | Итого |
| ------------ | ------------ | ----------- | ----------- |
|  Serial Collector |  5 (0.264s) |  3 (1.015s) | 1,279s |

| GC |  PS MarkSweep | PS Scavenge  | Итого |
| ------------ | ------------ | ----------- | ----------- |
|  Parallel Collector |  4 (2,067s) |  3 (0,230s) | 2,297s |
-------------------------------------------------------------------
------------------------------------------------------------------
*-Xms4096m
-Xmx4096m*
* Добавление по 100к элементов в коллецию, sleep 3000ms

| GC |  YoungCollections | OldCollections  | Итого |
| ------------ | ------------ | ----------- | ----------- |
|  G1 |  15 (5,327s) |  2 (9,355s) | 14,682‬s |

| GC |  Copy | MarkSweepCompact  | Итого |
| ------------ | ------------ | ----------- | ----------- |
|  Serial Collector |  4 (5,866s) |  1 (8,568s) | 14,434‬s |

| GC |  PS MarkSweep | PS Scavenge  | Итого |
| ------------ | ------------ | ----------- | ----------- |
|  Parallel Collector |  2 (18,255s) |  3 (5,271s) | 23,526s |

**Выводы:** для выбранного алгоритма (добавление большого количества объектов в коллекцию и 
удалению только половины) получились неожиданные результаты:
как при малом так и большом размере хипа выигрывает Serial Collector, за счет редких и быстрых сборок.
G1 проигрывает из-за слишком частого запуска сборок, а Parallel Collector несмотря на малое количество
запусков, выполняется слишком медленно, возможно из-за наличия всего двух ядер у процессора.